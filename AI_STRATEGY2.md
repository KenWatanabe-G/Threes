# Threes! AI Strategy Design Document

このドキュメントでは、Threes! を自動プレイするAI（CPU）のアルゴリズムと評価関数の設計について記述する。

## 1. 基本アーキテクチャ: Expectimax法

Threes! は「プレイヤーの意思決定」と「ランダムなタイルの出現」が交互に行われるゲームであるため、**Expectimax（期待値最大化）法**を採用する。

- **Maxノード（プレイヤー）:** 上下左右の4手から、最も評価値が高い手を選ぶ。
- **Chanceノード（環境）:** 移動後に「どこに」「何の数字が」出現するかを確率的に計算し、その平均（期待値）をスコアとする。

### 探索深度
計算リソースにもよるが、リアルタイム動作のためには **Depth 3〜4**（2手〜2.5手先読み）程度を推奨。

---

## 2. 評価関数 (Heuristics)

盤面の良し悪しを数値化する評価関数 $E(state)$ を定義する。
最終的なスコアは、以下の要素の重み付き和とする。

$$Score = w_1 \cdot Openness + w_2 \cdot Monotonicity + w_3 \cdot Smoothness + w_4 \cdot Adjacency$$

### A. 空きマスの数 (Openness)
盤面の自由度を確保するため、空きマス（0）の数を評価する。
- **目的:** ゲームオーバー（詰み）の回避。
- **計算:** 空きマスの数、あるいは空きマス数の乗数。

### B. 単調性 (Monotonicity) / 蛇行配置
大きな数字から小さな数字へ、綺麗に並んでいるかを評価する。
Threes! の定石である「トイレットペーパー型（蛇行型）」の配置を目指す。
- **目的:** 連鎖的なマージを可能にする。
- **計算:**
  - 左上隅を頂点とし、`左→右`、`一段下がって右→左` ... と進むルート上で、数字が降順になっているかチェックする。
  - 順序が守られているペアごとにボーナス点。

### C. 滑らかさ (Smoothness)
隣り合う数字の差が小さいほど良いとする。
- **目的:** 孤立した数字を作らない。隣同士が合体しやすい状態を維持する。
- **計算:** 全ての隣接ペアについて、`abs(log2(A) - log2(B))` を計算し、差が小さいほど高評価（差が大きいとペナルティ）。
- **特記事項:** `1` と `2` は合体可能だが、数値差は小さいので自然に評価される。ただし、`1`と`1`、`2`と`2`が隣接している場合は強いペナルティを与える（これらは合体できず、邪魔になるため）。

### D. 1と2のペアリング (Adjacency of 1 & 2)
Threes! 特有のルール。「1」と「2」は互いにしか合体できない。
- **目的:** 1と2の処理促進。
- **計算:**
  - 「1」の隣に「2」がある場合：ボーナス。
  - 「1」の隣に「1」がある場合：ペナルティ。
  - 「1」の隣に「3以上」がある場合：ペナルティ（壁になるため）。

---

## 3. 確率計算 (Probability Logic)

Chanceノードでの確率計算において、Threes! 固有の仕様を考慮する。

### A. デッキシステムの推測 (Deck Counting)
Threes! は完全ランダムではなく、12枚1セット（1x4, 2x4, 3x4）のデッキからカードが引かれる。
- **実装:**
  - ゲーム開始時からの出現カードをカウントする。
  - デッキの残りを計算し、次に出るカードが `1`, `2`, `3` である確率を動的に変動させる。
  - *簡易版:* 実装が複雑になる場合、一律 `33%` として扱ってもそれなりの精度は出る。

### B. ボーナスカード (Bonus Tile)
最大数が48を超えると、`3` の代わりに `6, 12...` が出る可能性がある。
- **実装:** 現在の盤面の最大値 ($Max$) を取得し、出現カードの候補に $Max / 8$ 以下の数値を含める。

### C. 次の色情報の利用 (Next Hint)
**最重要:** ゲーム画面には常に「次は青(1)」「次は赤(2)」「次は白(3+)」というヒントが出ている。
- AIはこの情報を **確実な入力** として受け取る必要がある。
- 青が来ると分かっているなら、探索木において「赤」や「白」が出る分岐をカット（Pruning）できるため、探索効率が劇的に向上する。

---

## 4. 高速化テクニック

### A. 枝刈り (Pruning)
- 有効な手が4方向全てあるとは限らない（壁にぶつかる等）。動けない方向は探索しない。
- 確率が極端に低いイベント（例: 0.1%の確率でボーナスカードが出るなど）は無視して枝刈りする。

### B. トランスポジションテーブル (Transposition Table)
- 異なる手順でも同じ盤面になることが多い（例: 上→右 と 右→上）。
- 盤面のハッシュ値をキーにして評価値を保存し、再計算を防ぐ。

---

## 5. 実装ステップ案

1.  **State管理クラス:** 盤面データ、スコア、Nextヒントを保持するクラスを作成。
2.  **Moveロジック:** `slide(direction)` 関数を実装（先日作成したロジックを流用）。
3.  **Evaluator:** 静的な盤面評価関数を実装。まずは「空きマス数」と「最大値が隅にあるか」だけでテストする。
4.  **Solver (Search):** Expectimax法を実装。最初はDepth=1から始め、徐々に深くする。
5.  **Tuning:** パラメータ（重み $w_1 \dots w_4$）を調整する。